// Auto-generated by generate-form - DO NOT EDIT
// Source: otherExample.ts
// @ts-nocheck

import { useState, useCallback } from 'react'
import { z } from 'zod'
import Box from '@mui/material/Box'
import Card from '@mui/material/Card'
import TextField from '@mui/material/TextField'
import Button from '@mui/material/Button'
import IconButton from '@mui/material/IconButton'
import FormControl from '@mui/material/FormControl'
import FormControlLabel from '@mui/material/FormControlLabel'
import FormHelperText from '@mui/material/FormHelperText'
import InputLabel from '@mui/material/InputLabel'
import Select from '@mui/material/Select'
import MenuItem from '@mui/material/MenuItem'
import Switch from '@mui/material/Switch'
import CircularProgress from '@mui/material/CircularProgress'
import Alert from '@mui/material/Alert'
import Stack from '@mui/material/Stack'
import Typography from '@mui/material/Typography'
import DeleteIcon from '@mui/icons-material/Delete'
import AddIcon from '@mui/icons-material/Add'
import { UserSchema } from '../../schemas/otherExample.schema'
import { useUserStore } from '../../stores/generated/otherExample.store'

export interface UserFormProps {
  onSubmit?: (data: z.infer<typeof UserSchema>) => void | Promise<void>
  onCancel?: () => void
  submitLabel?: string
  cancelLabel?: string
}

export function UserForm({
  onSubmit,
  onCancel,
  submitLabel = 'Submit',
  cancelLabel = 'Cancel',
}: UserFormProps) {
  const { id, name, email, isActive, age, addresses, orders, setId, setName, setEmail, setIsActive, setAge, appendAddresses, removeAddressesAt, updateAddressesAt, appendOrders, removeOrdersAt, updateOrdersAt, resetUser } = useUserStore()

  const [errors, setErrors] = useState<Record<string, string>>({})
  const [touched, setTouched] = useState<Record<string, boolean>>({})
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [submitError, setSubmitError] = useState<string | null>(null)

  const formData = { id, name, email, isActive, age, addresses, orders }

  const validateField = useCallback((field: string, value: unknown) => {
    try {
      const fieldSchema = UserSchema.shape[field as keyof typeof UserSchema.shape]
      if (fieldSchema) {
        fieldSchema.parse(value)
        setErrors((prev) => {
          const next = { ...prev }
          delete next[field]
          return next
        })
      }
    } catch (err) {
      if (err instanceof z.ZodError) {
        setErrors((prev) => ({
          ...prev,
          [field]: err.issues[0]?.message || 'Invalid value',
        }))
      }
    }
  }, [])

  const handleBlur = (field: string) => {
    setTouched((prev) => ({ ...prev, [field]: true }))
    validateField(field, formData[field as keyof typeof formData])
  }

  const validateForm = (): boolean => {
    const result = UserSchema.safeParse(formData)
    if (!result.success) {
      const newErrors: Record<string, string> = {}
      result.error.issues.forEach((err) => {
        const field = err.path[0]?.toString()
        if (field) {
          newErrors[field] = err.message
        }
      })
      setErrors(newErrors)
      setTouched(Object.keys(newErrors).reduce((acc, key) => ({ ...acc, [key]: true }), {}))
      return false
    }
    setErrors({})
    return true
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setSubmitError(null)

    if (!validateForm()) {
      return
    }

    setIsSubmitting(true)
    try {
      await onSubmit?.(formData as z.infer<typeof UserSchema>)
    } catch (err) {
      setSubmitError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setIsSubmitting(false)
    }
  }

  const handleReset = () => {
    resetUser()
    setErrors({})
    setTouched({})
    setSubmitError(null)
  }

  const isDirty = Object.keys(touched).length > 0
  const hasErrors = Object.keys(errors).length > 0

  return (
    <Box component="form" onSubmit={handleSubmit} noValidate>
      <Stack spacing={3}>
        {submitError && (
          <Alert severity="error" onClose={() => setSubmitError(null)}>
            {submitError}
          </Alert>
        )}

        <TextField
          fullWidth
          label="Id"
          value={id}
          onChange={(e) => setId(e.target.value)}
          onBlur={() => handleBlur('id')}
          error={touched['id'] && !!errors['id']}
          helperText={touched['id'] && errors['id']}
          required={true}
          disabled={false}
        />

        <TextField
          fullWidth
          label="Name"
          value={name}
          onChange={(e) => setName(e.target.value)}
          onBlur={() => handleBlur('name')}
          error={touched['name'] && !!errors['name']}
          helperText={touched['name'] && errors['name']}
          required={true}
          disabled={false}
        />

        <TextField
          fullWidth
          label="Email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          onBlur={() => handleBlur('email')}
          error={touched['email'] && !!errors['email']}
          helperText={touched['email'] && errors['email']}
          required={true}
          disabled={false}
        />

        <FormControlLabel
          control={
            <Switch
              checked={isActive}
              onChange={(e) => setIsActive(e.target.checked)}
              onBlur={() => handleBlur('isActive')}
            />
          }
          label="Is Active"
        />

        <TextField
          fullWidth
          type="number"
          label="Age"
          value={age}
          onChange={(e) => setAge(e.target.value === '' ? 0 : Number(e.target.value))}
          onBlur={() => handleBlur('age')}
          error={touched['age'] && !!errors['age']}
          helperText={touched['age'] && errors['age']}
          required={true}
        />

        <Box>
          <Stack direction="row" alignItems="center" justifyContent="space-between" sx={{ mb: 1 }}>
            <Typography variant="subtitle1">Addresses *</Typography>
            <Button
              size="small"
              startIcon={<AddIcon />}
              onClick={() => appendAddresses({ street: '', city: '', state: '', zipCode: '', country: '', isDefault: false } as never)}
            >
              Add
            </Button>
          </Stack>
          {touched['addresses'] && errors['addresses'] && (
            <FormHelperText error>{errors['addresses']}</FormHelperText>
          )}
          <Stack spacing={2}>
            {addresses.map((item, index) => (
              <Card key={index} variant="outlined" sx={{ p: 2 }}>
                <Stack spacing={2}>
                  <Stack direction="row" justifyContent="space-between" alignItems="center">
                    <Typography variant="subtitle2" color="text.secondary">
                      Addresses #{'${index + 1}'}
                    </Typography>
                    <IconButton
                      size="small"
                      color="error"
                      onClick={() => removeAddressesAt(index)}
                    >
                      <DeleteIcon />
                    </IconButton>
                  </Stack>
                  <TextField
                    fullWidth
                    size="small"
                    label="Street"
                    value={item.street || ''}
                    onChange={(e) => updateAddressesAt(index, { street: e.target.value })}
                  />
                  <TextField
                    fullWidth
                    size="small"
                    label="City"
                    value={item.city || ''}
                    onChange={(e) => updateAddressesAt(index, { city: e.target.value })}
                  />
                  <TextField
                    fullWidth
                    size="small"
                    label="State"
                    value={item.state || ''}
                    onChange={(e) => updateAddressesAt(index, { state: e.target.value })}
                  />
                  <TextField
                    fullWidth
                    size="small"
                    label="Zip Code"
                    value={item.zipCode || ''}
                    onChange={(e) => updateAddressesAt(index, { zipCode: e.target.value })}
                  />
                  <TextField
                    fullWidth
                    size="small"
                    label="Country"
                    value={item.country || ''}
                    onChange={(e) => updateAddressesAt(index, { country: e.target.value })}
                  />
                  <FormControlLabel
                    control={
                      <Switch
                        checked={item.isDefault ?? false}
                        onChange={(e) => updateAddressesAt(index, { isDefault: e.target.checked })}
                      />
                    }
                    label="Is Default"
                  />
                </Stack>
              </Card>
            ))}
            {addresses.length === 0 && (
              <Typography variant="body2" color="text.secondary" sx={{ py: 2, textAlign: 'center' }}>
                No items. Click "Add" to add one.
              </Typography>
            )}
          </Stack>
        </Box>

        <Box>
          <Stack direction="row" alignItems="center" justifyContent="space-between" sx={{ mb: 1 }}>
            <Typography variant="subtitle1">Orders *</Typography>
            <Button
              size="small"
              startIcon={<AddIcon />}
              onClick={() => appendOrders({ orderId: '', status: 'pending', priority: 'low', totalAmount: 0, itemCount: 0, product: { id: '', name: '', description: '', price: 0, inStock: false, quantity: 0 } } as never)}
            >
              Add
            </Button>
          </Stack>
          {touched['orders'] && errors['orders'] && (
            <FormHelperText error>{errors['orders']}</FormHelperText>
          )}
          <Stack spacing={2}>
            {orders.map((item, index) => (
              <Card key={index} variant="outlined" sx={{ p: 2 }}>
                <Stack spacing={2}>
                  <Stack direction="row" justifyContent="space-between" alignItems="center">
                    <Typography variant="subtitle2" color="text.secondary">
                      Orders #{'${index + 1}'}
                    </Typography>
                    <IconButton
                      size="small"
                      color="error"
                      onClick={() => removeOrdersAt(index)}
                    >
                      <DeleteIcon />
                    </IconButton>
                  </Stack>
                  <TextField
                    fullWidth
                    size="small"
                    label="Order Id"
                    value={item.orderId || ''}
                    onChange={(e) => updateOrdersAt(index, { orderId: e.target.value })}
                  />
                  <FormControl fullWidth size="small">
                    <InputLabel>Status</InputLabel>
                    <Select
                      value={item.status || ''}
                      label="Status"
                      onChange={(e) => updateOrdersAt(index, { status: e.target.value })}
                    >
                      <MenuItem value="pending">Pending</MenuItem>
                      <MenuItem value="processing">Processing</MenuItem>
                      <MenuItem value="shipped">Shipped</MenuItem>
                      <MenuItem value="delivered">Delivered</MenuItem>
                      <MenuItem value="cancelled">Cancelled</MenuItem>
                    </Select>
                  </FormControl>
                  <FormControl fullWidth size="small">
                    <InputLabel>Priority</InputLabel>
                    <Select
                      value={item.priority || ''}
                      label="Priority"
                      onChange={(e) => updateOrdersAt(index, { priority: e.target.value })}
                    >
                      <MenuItem value="low">Low</MenuItem>
                      <MenuItem value="medium">Medium</MenuItem>
                      <MenuItem value="high">High</MenuItem>
                    </Select>
                  </FormControl>
                  <TextField
                    fullWidth
                    size="small"
                    type="number"
                    label="Total Amount"
                    value={item.totalAmount ?? 0}
                    onChange={(e) => updateOrdersAt(index, { totalAmount: e.target.value === '' ? 0 : Number(e.target.value) })}
                  />
                  <TextField
                    fullWidth
                    size="small"
                    type="number"
                    label="Item Count"
                    value={item.itemCount ?? 0}
                    onChange={(e) => updateOrdersAt(index, { itemCount: e.target.value === '' ? 0 : Number(e.target.value) })}
                  />
                  <Box sx={{ border: 1, borderColor: 'divider', borderRadius: 1, p: 2 }}>
                    <Typography variant="subtitle2" sx={{ mb: 1 }}>Product</Typography>
                    <Stack spacing={1}>
                      <TextField
                        fullWidth
                        size="small"
                        label="Id"
                        value={item.product?.id || ''}
                        onChange={(e) => updateOrdersAt(index, { product: { ...item.product, id: e.target.value } })}
                      />
                      <TextField
                        fullWidth
                        size="small"
                        label="Name"
                        value={item.product?.name || ''}
                        onChange={(e) => updateOrdersAt(index, { product: { ...item.product, name: e.target.value } })}
                      />
                      <TextField
                        fullWidth
                        size="small"
                        label="Description"
                        value={item.product?.description || ''}
                        onChange={(e) => updateOrdersAt(index, { product: { ...item.product, description: e.target.value } })}
                      />
                      <TextField
                        fullWidth
                        size="small"
                        type="number"
                        label="Price"
                        value={item.product?.price ?? 0}
                        onChange={(e) => updateOrdersAt(index, { product: { ...item.product, price: e.target.value === '' ? 0 : Number(e.target.value) } })}
                      />
                      <FormControlLabel
                        control={
                          <Switch
                            checked={item.product?.inStock ?? false}
                            onChange={(e) => updateOrdersAt(index, { product: { ...item.product, inStock: e.target.checked } })}
                          />
                        }
                        label="In Stock"
                      />
                      <TextField
                        fullWidth
                        size="small"
                        type="number"
                        label="Quantity"
                        value={item.product?.quantity ?? 0}
                        onChange={(e) => updateOrdersAt(index, { product: { ...item.product, quantity: e.target.value === '' ? 0 : Number(e.target.value) } })}
                      />
                    </Stack>
                  </Box>
                </Stack>
              </Card>
            ))}
            {orders.length === 0 && (
              <Typography variant="body2" color="text.secondary" sx={{ py: 2, textAlign: 'center' }}>
                No items. Click "Add" to add one.
              </Typography>
            )}
          </Stack>
        </Box>

        <Stack direction="row" spacing={2} justifyContent="flex-end">
          {onCancel && (
            <Button
              type="button"
              variant="outlined"
              onClick={onCancel}
              disabled={isSubmitting}
            >
              {cancelLabel}
            </Button>
          )}
          <Button
            type="button"
            variant="outlined"
            onClick={handleReset}
            disabled={isSubmitting || !isDirty}
          >
            Reset
          </Button>
          <Button
            type="submit"
            variant="contained"
            disabled={isSubmitting || hasErrors}
            startIcon={isSubmitting ? <CircularProgress size={20} /> : null}
          >
            {isSubmitting ? 'Submitting...' : submitLabel}
          </Button>
        </Stack>
      </Stack>
    </Box>
  )
}
