// Auto-generated by generate-form - DO NOT EDIT
// Source: example.ts
// @ts-nocheck

import { useState, useCallback } from 'react'
import { z } from 'zod'
import Box from '@mui/material/Box'
import Card from '@mui/material/Card'
import TextField from '@mui/material/TextField'
import Button from '@mui/material/Button'
import IconButton from '@mui/material/IconButton'
import FormControl from '@mui/material/FormControl'
import FormControlLabel from '@mui/material/FormControlLabel'
import FormHelperText from '@mui/material/FormHelperText'
import InputLabel from '@mui/material/InputLabel'
import Select from '@mui/material/Select'
import MenuItem from '@mui/material/MenuItem'
import Switch from '@mui/material/Switch'
import CircularProgress from '@mui/material/CircularProgress'
import Alert from '@mui/material/Alert'
import Stack from '@mui/material/Stack'
import Typography from '@mui/material/Typography'
import DeleteIcon from '@mui/icons-material/Delete'
import AddIcon from '@mui/icons-material/Add'
import { AirPlaneSchema } from '../../schemas/example.schema'
import { useAirPlaneStore } from '../../stores/generated/example.store'

export interface AirPlaneFormProps {
  onSubmit?: (data: z.infer<typeof AirPlaneSchema>) => void | Promise<void>
  onCancel?: () => void
  submitLabel?: string
  cancelLabel?: string
}

export function AirPlaneForm({
  onSubmit,
  onCancel,
  submitLabel = 'Submit',
  cancelLabel = 'Cancel',
}: AirPlaneFormProps) {
  const { id, model, manufacturer, capacity, range, inService, setId, setModel, setManufacturer, setCapacity, setRange, setInService, resetAirPlane } = useAirPlaneStore()

  const [errors, setErrors] = useState<Record<string, string>>({})
  const [touched, setTouched] = useState<Record<string, boolean>>({})
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [submitError, setSubmitError] = useState<string | null>(null)

  const formData = { id, model, manufacturer, capacity, range, inService }

  const validateField = useCallback((field: string, value: unknown) => {
    try {
      const fieldSchema = AirPlaneSchema.shape[field as keyof typeof AirPlaneSchema.shape]
      if (fieldSchema) {
        fieldSchema.parse(value)
        setErrors((prev) => {
          const next = { ...prev }
          delete next[field]
          return next
        })
      }
    } catch (err) {
      if (err instanceof z.ZodError) {
        setErrors((prev) => ({
          ...prev,
          [field]: err.issues[0]?.message || 'Invalid value',
        }))
      }
    }
  }, [])

  const handleBlur = (field: string) => {
    setTouched((prev) => ({ ...prev, [field]: true }))
    validateField(field, formData[field as keyof typeof formData])
  }

  const validateForm = (): boolean => {
    const result = AirPlaneSchema.safeParse(formData)
    if (!result.success) {
      const newErrors: Record<string, string> = {}
      result.error.issues.forEach((err) => {
        const field = err.path[0]?.toString()
        if (field) {
          newErrors[field] = err.message
        }
      })
      setErrors(newErrors)
      setTouched(Object.keys(newErrors).reduce((acc, key) => ({ ...acc, [key]: true }), {}))
      return false
    }
    setErrors({})
    return true
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setSubmitError(null)

    if (!validateForm()) {
      return
    }

    setIsSubmitting(true)
    try {
      await onSubmit?.(formData as z.infer<typeof AirPlaneSchema>)
    } catch (err) {
      setSubmitError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setIsSubmitting(false)
    }
  }

  const handleReset = () => {
    resetAirPlane()
    setErrors({})
    setTouched({})
    setSubmitError(null)
  }

  const isDirty = Object.keys(touched).length > 0
  const hasErrors = Object.keys(errors).length > 0

  return (
    <Box component="form" onSubmit={handleSubmit} noValidate>
      <Stack spacing={3}>
        {submitError && (
          <Alert severity="error" onClose={() => setSubmitError(null)}>
            {submitError}
          </Alert>
        )}

        <TextField
          fullWidth
          label="Id"
          value={id}
          onChange={(e) => setId(e.target.value)}
          onBlur={() => handleBlur('id')}
          error={touched['id'] && !!errors['id']}
          helperText={touched['id'] && errors['id']}
          required={true}
          disabled={false}
        />

        <TextField
          fullWidth
          label="Model"
          value={model}
          onChange={(e) => setModel(e.target.value)}
          onBlur={() => handleBlur('model')}
          error={touched['model'] && !!errors['model']}
          helperText={touched['model'] && errors['model']}
          required={true}
          disabled={false}
        />

        <TextField
          fullWidth
          label="Manufacturer"
          value={manufacturer}
          onChange={(e) => setManufacturer(e.target.value)}
          onBlur={() => handleBlur('manufacturer')}
          error={touched['manufacturer'] && !!errors['manufacturer']}
          helperText={touched['manufacturer'] && errors['manufacturer']}
          required={true}
          disabled={false}
        />

        <TextField
          fullWidth
          type="number"
          label="Capacity"
          value={capacity}
          onChange={(e) => setCapacity(e.target.value === '' ? 0 : Number(e.target.value))}
          onBlur={() => handleBlur('capacity')}
          error={touched['capacity'] && !!errors['capacity']}
          helperText={touched['capacity'] && errors['capacity']}
          required={true}
        />

        <TextField
          fullWidth
          type="number"
          label="Range"
          value={range}
          onChange={(e) => setRange(e.target.value === '' ? 0 : Number(e.target.value))}
          onBlur={() => handleBlur('range')}
          error={touched['range'] && !!errors['range']}
          helperText={touched['range'] && errors['range']}
          required={true}
        />

        <FormControlLabel
          control={
            <Switch
              checked={inService}
              onChange={(e) => setInService(e.target.checked)}
              onBlur={() => handleBlur('inService')}
            />
          }
          label="In Service"
        />

        <Stack direction="row" spacing={2} justifyContent="flex-end">
          {onCancel && (
            <Button
              type="button"
              variant="outlined"
              onClick={onCancel}
              disabled={isSubmitting}
            >
              {cancelLabel}
            </Button>
          )}
          <Button
            type="button"
            variant="outlined"
            onClick={handleReset}
            disabled={isSubmitting || !isDirty}
          >
            Reset
          </Button>
          <Button
            type="submit"
            variant="contained"
            disabled={isSubmitting || hasErrors}
            startIcon={isSubmitting ? <CircularProgress size={20} /> : null}
          >
            {isSubmitting ? 'Submitting...' : submitLabel}
          </Button>
        </Stack>
      </Stack>
    </Box>
  )
}
