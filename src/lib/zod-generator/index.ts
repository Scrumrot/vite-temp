import { parseTypeScriptFile, type ParsedDeclaration } from './type-parser'
import {
  buildSchemaString,
  generateTypeExport,
  type BuildContext,
} from './schema-builder'
import { topologicalSort, findRecursiveTypes } from './dependency-resolver'
import * as path from 'path'

export interface GeneratorOptions {
  verbose?: boolean
}

export interface GeneratorResult {
  code: string
  warnings: string[]
  generatedTypes: string[]
}

export async function generateZodSchemas(
  inputPath: string,
  options: GeneratorOptions = {}
): Promise<GeneratorResult> {
  const { verbose = false } = options
  const warnings: string[] = []
  const generatedTypes: string[] = []

  if (verbose) {
    console.log(`Parsing: ${inputPath}`)
  }

  // Parse the TypeScript file
  const { declarations } = parseTypeScriptFile(inputPath)

  if (verbose) {
    console.log(`Found ${declarations.length} type declarations`)
  }

  // Build dependency graph
  const dependencyGraph = new Map<string, Set<string>>()
  const declarationMap = new Map<string, ParsedDeclaration>()

  for (const decl of declarations) {
    dependencyGraph.set(decl.name, decl.dependencies)
    declarationMap.set(decl.name, decl)
  }

  // Find recursive types
  const recursiveTypes = findRecursiveTypes(dependencyGraph)
  if (verbose && recursiveTypes.size > 0) {
    console.log(`Recursive types: ${[...recursiveTypes].join(', ')}`)
  }

  // Sort types by dependencies
  let sortedTypeNames: string[]
  try {
    sortedTypeNames = topologicalSort(dependencyGraph)
  } catch (error) {
    if (error instanceof Error) {
      warnings.push(error.message)
    }
    // Fallback to original order if circular dependency detected
    sortedTypeNames = declarations.map((d) => d.name)
  }

  if (verbose) {
    console.log(`Generation order: ${sortedTypeNames.join(' -> ')}`)
  }

  // Build context
  const context: BuildContext = {
    knownTypes: new Set(declarations.map((d) => d.name)),
    recursiveTypes,
    warnings,
  }

  // Generate schemas in dependency order
  const schemaStrings: string[] = []
  const typeExports: string[] = []

  for (const typeName of sortedTypeNames) {
    const decl = declarationMap.get(typeName)
    if (!decl) continue

    // Only generate for exported types
    if (!decl.isExported) {
      if (verbose) {
        console.log(`Skipping non-exported type: ${typeName}`)
      }
      continue
    }

    const schemaString = buildSchemaString(decl, context)
    if (schemaString) {
      schemaStrings.push(schemaString)
      typeExports.push(generateTypeExport(typeName))
      generatedTypes.push(typeName)

      if (verbose) {
        console.log(`Generated: ${typeName}Schema`)
      }
    }
  }

  // Build the final output
  const relativePath = path.basename(inputPath)
  const header = [
    '// Auto-generated by generate-zod - DO NOT EDIT',
    `// Source: ${relativePath}`,
    '',
    "import { z } from 'zod';",
    '',
  ].join('\n')

  const code = [
    header,
    ...schemaStrings,
    '',
    '// Type exports',
    ...typeExports,
    '',
  ].join('\n')

  return {
    code,
    warnings: context.warnings,
    generatedTypes,
  }
}

export { parseTypeScriptFile } from './type-parser'
export { topologicalSort } from './dependency-resolver'
export type { ParsedDeclaration, ParsedType, ParsedProperty } from './type-parser'
